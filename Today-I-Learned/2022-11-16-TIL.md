# 2022-11-16 Today I Learned

## 인터페이스

### 1. private 메소드
- private 메소드는 구현 객체가 필요한 메소드다.
- private 정적 메소드는 구현 객체가 필요 없는 메소드다.
- private 메소드의 용도는 디폴트와 정적 메소드들의 중복 코드를 줄이기 위함에 있다.
> default void defaultMethod1() {<br>
> sout("defaultMethod1 종속 코드");<br>
> defaultCommon();
> }<br>
>
> default void defaultMethod2() {<br>
> sout("defaultMethod2 종속 코드");<br>
> defaultCommon();}<br>
><br>
> private void defaultCommon() {<br>
> sout("defaultMethod 중복 코드 A");
> sout("defaultMethod 중복 코드 B");}<br>

- 위와 같이 private 메소드로 method 들의 공통된 부분을 뽑아내는 용도로 사용한다.

### 2. 다중 인터페이스 구현
- 인터페이스를 구현한 객체는 여러 개의 인터페이스를 구현 할 수 있다. 구현 객체가 인터페이스 A,B를 구현하고 있다면
  각각의 인터페이스 A,B를 통해 구현 객체를 사용할 수 있다.
> public class 구현클래스명 implements 인터페이스A, 인터페이스B {
> //모든 추상 메소드 재정의 ★★★★}
- 인터페이스를 구현한 객체는 두 인터페이스 타입의 변수에 각각 대입 될 수 있다.
> 인터페이스A 변수 = new 구현클래스명(...);
> 인터페이스B 변수 = new 구현클래스명(...);

### 3.인터페이스 상속
- 인터페이스도다른 인터페이스를 상속할 수 있고, 클래스와는 달리 다중 상속을 허용한다.
> public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 {...}
- 자식 인터페이스의 구현 클래스는 자식 인터페이스의 메소드 뿐 아니라 부모 인터페이스의 모든 추상 메소드를 재정의해야 한다.
> 자식인터페이스 변수 = new 구현클래스(...);
> 부모인터페이스1 변수 = new 구현클래스(...);
> 부모인터페이스2 변수 = new 구현클래스(...);
- 구현 객체가 자식 인터페이스 변수에 대입되면 자식,부모 인터페이스의 추상 메소드를 모두 호출할 수 있으나
  부모 인터페이스 변수에 대입되면 부모 인터페이스에 선언된 추상 메소드만 호출 가능.

### 4.타입 변환
- 인터페이스의 타입 변환은 인터페이스와 구현 클래스 간 발생함.
- 인터페이스 변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입 변환된다.
- 인터페이스 타입을 구현 클래스 타입으로 변환시킬때는 강제 타입 변환이 필요.

#### 1) 자동 타입 변환
> 인터페이스 변수 = 구현객체;
- 위의 상황일 때 자동 타입 변환이 이뤄진다.
- 예를 들어 인터페이스 A 가 있고, 이를 구현한 B,C 클래스가 있고 각각 B,C클래스를 상속한 D,E 클래스가 있다고 하자.
> B b = new B();<br>
> C c = new C();<br>
> ... 같이 구현 객체를 생성하고 <br>
> A a -> 인터페이스 변수를 선언 <br>
> 그 인터페이스 변수에 구현 객체를 대입하면 <br>
> a = b;<br>
> a = c;<br>
> a = d;<br>
> a = e;<br>
> 위 구현 객체들은 인터페이스로 자동 타입 변환된다.

#### 2) 강제 타입 변환
- 강제 타입 변환은 캐스팅 기호를 사용해 인텊이스 타입을 구현 클래스 타입으로 변환시키는 것이다.
> 구현클래스 변수 = (구현클래스) 인터페이스변수;
- 문자열, 정수형 으로 강제변환하는 것과 같은 방식이다.
##### (1) 강제 타입 변환의 목적
- 구현 객체가 인터페이스 타입으로 자동 변환되면 인터페이스에 선언된 메소드만 사용 가능하다.
- A라는 인터페이스에 3개의 메소드가 있고 B 클래스에는 5개의 메소드가 선언되어 있다면 A 인터페이스로
  호출 가능한 메소드는 3개뿐이다.
- 이 때 강제 타입 변환을 통해 B 클래스의 나머지 2개의 메소드를 사용할 수 있게 된다.

### 5.다형성
- 인터페이스 또한 상속과 같이 다형성을 구현하는 주된 기술로 사용된다. 그리고 실제 개발환경에서는
  인터페이스를 통해 다형성을 구현하는 경우가 더 많다.
- 인터페이스로 다형성을 구현하기 위해 메소드 재정의와 자동 타입 변환 기능을 이용한다.

#### 1) 필드의 다형성
- Tire 라는 인터페이스가 있고, 이를 구현한 A,B 타이어 클래스가 있다.
- 그리고 Car 라는 클래스가 있고, Car 클래스에서<br>
> Tire tire1 = new ATire();<br>
> Tire tire2 = new BTire();<br>
- 위와 같이 필드를 선언하고
> void run() {<br>
> tire1.roll();<br>
> tire2.roll();<br>
- 메소드를 선언했다고 하자. 그러면 실행 메소드에서 Car의 객체를 생성하고 run() 메소드를 실행하면 A 타이어에서
  재정의한 run() 메소드가 실행된다.
- 이를 다시 B타이어로 바꾸고 싶다면 객체를 교체하면 된다.
> myCar.tire1 = new BTire();<br>
> myCar.tire2 = new BTire();<br>
- 이렇게 변경 후 다시 run() 메소드를 실행한다면 이번에는 B 타이어에서 재정의한 메소드가 실행되게 된다.

#### 2)매개변수의 다형성
- 메소드 호출 시 매개값을 다양화하기 위해 상속에선 매개변수 타입을 부모 타입으로 선언 후 호출할 땐 다양한 자식 객체를 대입했다.
- 이는 자동 타입 변환 때문인데, 비슷한 원리로 매개변수 타입을 인터페이스로 선언하면 메소드 호출 시 다양한 구현 객체를
  대입할 수 있다.
- 먼저 Vehicle 라는 인터페이스가 다음과 같이 선언되었다고 하면
> public interface Vehicle {<br>
> void run();<br>
- 운전자 클래스인 Driver는 다양한 Vehicle 구현 객체를 운전하기 위해 Vehicle 인터페이스를 매개변수로 가지는
  drive() 메소드를 다음과 같이 선언했다고 해보자
> public class Driver {<br>
> void frive(Vehicle vehicle) {-> 구현 객체가 대입될 수 있도록 매개변수를 인터페이스 타입으로 선언한 것이다.<br>
> vehicle.run(); }} - 인터페이스의 추상 메소드 호출
- Bus가 Vehicle의 구현 클래스라면 다음과 같이 Driver의 drive() 메소드를 호출할 때 Bus 객체를 생성해서 매개값으로 줄 수 있다.
> Driver driver = new Driver();<br>
> Bus bus = new Bus();<br>
> driver.drive(bus);
> * Taxi taxi = new Taxi();<br>
> * driver.drive(taxi); 또한 가능하다.
- drive() 메소드를 호출할 때 인터페이스 Vehicle울 구현하는 어떤 객체라도 매개값으로 줄 수 있는데 어떤 객체를 주느냐에 따라 run() 메소드의
  실행 결과는 다르게 나온다. 이것이 매개변수의 다형성이다.

### 6. 객체 타입 확인
- 상속에서 객체 타입을 확인하기 위해 instanceof 연산자를 사용했는데 이를 인터페이스에서도 사용가능하다.
- 예를 들어 Vehicle 인터페이스 변수에 대입된 객체가 Bus인지 확인하는 코드는 다음과 같다.
> if(vehicle instanceof Bus) {...}<br>
> //vehicle에 대입된 객체가 Bus일 경우 실행한다는 의미다.
- 메소드의 매개변수가 인터페이스 타입일 경우, 메소드 호출 시 매개값은 해당 인터페이스를 구현하는 모든 객체가 될 수 있다.
- 매개값이 특정 구현 객체일 경우에만 강제 타입 변환을 하고 싶다면 instanceof 연산자를 사용해 매개값의 타입을 검사해야 한다.
> public void method(Vehicle vehicle) {<br>
> if(vehicle instanceof Bus) {<br>
> Bus bus = (Bus) vehicle; }}<br>
- vehicle에 대입된 객체가 Bus일 경우에만 Bus로 강제 타입 변환시킨다.
- 그리고 Java12 부터는 instanceof 연산의 겨로가가 true일 경우 우측 타입 변수를 사용할수 있어 강제 타입 변환이 필요없다.
> if(vehicle instanceof Bus bus) {...}<br>
> //bus 변수 사용

### 7.봉인된 인터페이스
- Java15 부터는 봉인된 인터페이스를 사용할 수 있다.
- InterfaceA의 자식 인터페이스는 InterfaceB만 가능하고, 그 이외는 자식 인터페이스가 될 수 없도록 다음과 같이 InterfaceA를 봉인된 인터페이스로 선언할 수 있다.
> public sealed interface InterfaceA permits InterfaceB {...}
- sealed 키워드를 사용하면 permits 키워드 뒤에 상속 가능한 자식 인터페이스를 위와 같이 지정해야 한다.
- 그 후 봉인된 InterfaceA를 상속하는 InterfaceB는 non-sealed 키워드로 선언하거나 sealed 키워드를 사용해서
  또 다른 봉인 인터페이스로 선언해야 한다.